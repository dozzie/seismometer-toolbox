#!/usr/bin/python

import sys
import optparse
import logging
import traceback
import socket
import json
import yaml

from seismometer import daemonshepherd
from seismometer.daemonshepherd.control_socket import ControlSocketClient
from seismometer.daemonshepherd.filehandle import EOF

#-----------------------------------------------------------------------------
# parse command line options {{{

parser = optparse.OptionParser(
    usage = "\n  %prog [options] --daemons=FILE"
            "\n  %prog [options] reload"
            "\n  %prog [options] ps"
            "\n  %prog [options] {start|stop|restart|cancel_restart} <daemon_name>"
            "\n  %prog [options] command <daemon_name> <command_name>",
    description = "Daemon supervisor/restarter.",
)

parser.add_option(
    "-f", "--daemons", dest = "daemons",
    help = "YAML file with daemons to control", metavar = "FILE",
)
parser.add_option(
    "-l", "--logging", dest = "logging",
    help = "YAML/JSON file with logging configuration", metavar = "FILE",
)
parser.add_option(
    "-s", "--control-socket", dest = "socket",
    help = "path to control socket", metavar = "PATH",
)
parser.add_option(
    "-p", "--pid-file", dest = "pid_file",
    help = "PID file for going daemon", metavar = "FILE",
)
parser.add_option(
    "-d", "--background", dest = "background",
    action = "store_true", default = False,
    help = "detach from terminal (run as a daemon)",
)
parser.add_option(
    "-u", "--user", dest = "user",
    help = "user to run as",
)
parser.add_option(
    "-g", "--group", dest = "group",
    help = "group to run as",
)

(options, args) = parser.parse_args()
# assume this until proven otherwise
command = "daemon_supervisor"

SOLE_COMMANDS = set(["reload", "ps"])
DAEMON_COMMANDS = set(["start", "stop", "restart", "cancel_restart"])
ADMIN_COMMANDS = set(["command"])
KNOWN_COMMANDS = SOLE_COMMANDS | DAEMON_COMMANDS | ADMIN_COMMANDS

if len(args) == 0 and options.daemons is None:
    parser.error("--daemons option is required for this mode")
elif len(args) > 0:
    command = args.pop(0)
    if command not in KNOWN_COMMANDS:
        parser.error("unrecognized command: %s" % (command,))
    if len(args) != 1 and command in DAEMON_COMMANDS:
        parser.error("daemon name is required for command %s" % (command,))
    if len(args) != 2 and command in ADMIN_COMMANDS:
        parser.error("daemon name and command name are required for command %s" % (command,))

if command != "daemon_supervisor" and options.socket is None:
    options.socket = "/var/run/daemonshepherd.sock"

# }}}
#-----------------------------------------------------------------------------

if command == "daemon_supervisor":
    #------------------------------------------------------
    # run as a daemon supervisor {{{

    pid_file = None
    controller = None

    # create pidfile (if applicable) 
    if options.pid_file is not None:
        pid_file = daemonshepherd.PidFile(options.pid_file)

    # change user/group (if applicable) 
    if options.user is not None or options.group is not None:
        daemonshepherd.setguid(options.user, options.group)

    # configure logging
    import seismometer.logging
    seismometer.logging.configure_from_file(options.logging, default = "null")

    # setup Python runtime to log all uncaught exceptions somewhere
    def exception_logger(exctype, value, tb):
        logger = logging.getLogger()
        logger.critical("Uncaught exception: %s", value)
        for chunk in traceback.format_exception(exctype, value, tb):
            for line in chunk.split("\n"):
                if line == "": continue
                logger.critical(line)
    sys.excepthook = exception_logger

    def load_config():
        with open(options.daemons) as f:
            config = yaml.safe_load(f)
            defaults = config.get("defaults", {})
            daemons = config.get("daemons", {})
            for daemon in daemons.values():
                for key in defaults:
                    if key not in daemon:
                        daemon[key] = defaults[key]
            return daemons

    # daemonize (if applicable) 
    if options.background:
        daemonshepherd.detach("/")
        if pid_file is not None:
            pid_file.update()

    if pid_file is not None:
        pid_file.claim() # remove on close

    # create controller thread 
    try:
        controller = daemonshepherd.Controller(load_config, options.socket)
    except Exception, e:
        print >>sys.stderr, str(e)
        sys.exit(1)

    # acknowledge success to parent process (if --background) 
    if options.background:
        daemonshepherd.detach_succeeded()

    # main loop
    controller.loop() # NOTE: SIGINT handler is set by the controller
    controller.shutdown()
    sys.exit()

    # }}}
    #------------------------------------------------------
else:
    conn = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        conn.connect(options.socket)
    except socket.error, e:
        print >>sys.stderr, e
        sys.exit(1)

    supervisor = ControlSocketClient(conn)

    if command in SOLE_COMMANDS:
        supervisor.send({"command": command})
    elif command in DAEMON_COMMANDS:
        supervisor.send({"command": command, "daemon": args[0]})
    elif command in ADMIN_COMMANDS:
        supervisor.send({
            "command": "admin_command",
            "daemon": args[0],
            "admin_command": args[1],
        })

    reply = supervisor.read(blocking = True)
    supervisor.close()

    if reply is EOF:
        print >>sys.stderr, \
              "Empty reply from daemonshepherd, probably a server bug."
        sys.exit(1)

    if reply.get("status") != "ok":
        print >>sys.stderr, json.dumps(reply)
        sys.exit(1)

    if command == "ps":
        for daemon in reply["result"]:
            print json.dumps(daemon)

#-----------------------------------------------------------------------------
# vim:ft=python:foldmethod=marker
