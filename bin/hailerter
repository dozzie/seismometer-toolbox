#!/usr/bin/python

import sys
import optparse
import logging
import traceback
import seismometer.logging
import signal
import json
import seismometer.message
import seismometer.poll

#-----------------------------------------------------------------------------
# command line options {{{

#-------------------------------------------------------
# custom option types {{{

def check_interval(option, opt, value):
    try:
        if value.endswith("h"):
            result = 60 * 60 * int(value[:-1])
        elif value.endswith("m"):
            result = 60 * int(value[:-1])
        elif value.endswith("s"):
            result = int(value[:-1])
        else: # no suffix
            result = int(value)
        if result > 0:
            return result
        raise optparse.OptionValueError(
            "option %s: negative interval value: %r" % (opt, value)
        )
    except ValueError:
        raise optparse.OptionValueError(
            "option %s: invalid interval value: %r" % (opt, value)
        )

def check_count(option, opt, value):
    try:
        result = int(value)
        if result > 0:
            return result
        raise optparse.OptionValueError(
            "option %s: negative count: %r" % (opt, value)
        )
    except ValueError:
        raise optparse.OptionValueError(
            "option %s: invalid count value: %r" % (opt, value)
        )

def check_fraction(option, opt, value):
    try:
        result = float(value)
        if 0.0 <= result and result <= 1.0:
            return result
        raise optparse.OptionValueError(
            "option %s: invalid fraction value: %r" % (opt, value)
        )
    except ValueError:
        raise optparse.OptionValueError(
            "option %s: invalid fraction value: %r" % (opt, value)
        )


class HailerterOption(optparse.Option):
    TYPES = optparse.Option.TYPES + (
        "interval",
        "count",
        "fraction",
    )
    TYPE_CHECKER = optparse.Option.TYPE_CHECKER.copy()
    TYPE_CHECKER["interval"] = check_interval
    TYPE_CHECKER["count"] = check_count
    TYPE_CHECKER["fraction"] = check_fraction

# }}}
#-------------------------------------------------------

parser = optparse.OptionParser(
    option_class = HailerterOption,
    usage = "%prog [options]",
    #description = "Foo bar baz.",
)

parser.add_option(
    "--logging", dest = "logging_config",
    default = None,
    help = "YAML/JSON file with logging configuration",
    metavar = "FILE",
)

parser.add_option(
    "--notify", dest = "notification_interval",
    type = "interval", default = 2 * 3600, # 2 hours
    help = "notification interval for streams that are still degraded,"
           " missing, or flapping (default: 2 hours)",
    metavar = "INTERVAL",
)
parser.add_option(
    "--default-interval", dest = "default_interval",
    type = "interval", default = None,
    help = "collection interval to assume for streams that don't provide one",
    metavar = "INTERVAL",
)
parser.add_option(
    "--missing", dest = "missing",
    type = "count", default = None,
    help = "number of messages after which stream is deemed missing",
    metavar = "COUNT",
)
parser.add_option(
    "--flapping-window", dest = "flapping_window",
    type = "count", default = None,
    help = "number of messages to calculate stream flapping",
    metavar = "COUNT",
)
parser.add_option(
    "--flapping-threshold", dest = "flapping_threshold",
    type = "fraction", default = None,
    help = "fraction of messages in flapping window to deem stream flapping",
    metavar = "FRACTION",
)

(options, args) = parser.parse_args()

# }}}
#-----------------------------------------------------------------------------
# logging configuration {{{

seismometer.logging.configure_from_file(options.logging_config, default = "stderr")
logger = logging.getLogger()

def exception_logger(exctype, value, tb):
    logger.critical("Uncaught exception: %s", value)
    for chunk in traceback.format_exception(exctype, value, tb):
        for line in chunk.split("\n"):
            if line == "": continue
            logger.critical(line)

sys.excepthook = exception_logger

# }}}
#-----------------------------------------------------------------------------
# signal handlers {{{

def quit_program(sig, stack_frame):
    logger.info("received signal; shutting down")
    sys.exit(0)

signal.signal(signal.SIGHUP, quit_program)
signal.signal(signal.SIGINT, quit_program)
signal.signal(signal.SIGTERM, quit_program)

# }}}
#-----------------------------------------------------------------------------
# core: state tracker machine

class StateTracker:
    def __init__(self):
        self._check_timeouts = False

    def install_alarm(self):
        signal.signal(signal.SIGALRM, self._handle_alarm)
        signal.alarm(1)

    def _handle_alarm(self, sig, stack_frame):
        self._check_timeouts = True
        signal.alarm(1)

    def missing_messages(self):
        if not self._check_timeouts:
            # don't do the busy work more often than on schedule
            return ()
        self._check_timeouts = False
        print "tick"
        return () # TODO

    def update_state(self, message):
        print "a message [\"%s\"] %s" % (message.aspect, repr(message.location))
        pass # TODO

#-----------------------------------------------------------------------------

# poll for a single handle may be a little overkill, but it should mix nice
# with SIGALRM and it allows to close STDIN and exit gracefully
poll = seismometer.poll.Poll()
poll.add(sys.stdin)

stm = StateTracker()
stm.install_alarm()

while not poll.empty():
    read_handles = poll.poll(timeout = None) # 1s loop

    for handle in read_handles:
        # TODO: read as much as possible, so the flush at the end of loop
        # works for an aggregate instead of every single line
        line = sys.stdin.readline()
        if line == "":
            poll.remove(handle)
            continue
        rec = json.loads(line) # TODO: catch deserialization errors
        if not seismometer.message.is_valid(rec):
            continue

        result = stm.update_state(seismometer.message.Message(rec))
        if result is not None:
            json.dump(result, sys.stdout)
            sys.stdout.write("\n")

    timeouts = stm.missing_messages()
    for msg in timeouts:
        json.dump(msg, sys.stdout)
        sys.stdout.write("\n")

    sys.stdout.flush()

#-----------------------------------------------------------------------------
# vim:ft=python:foldmethod=marker
