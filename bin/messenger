#!/usr/bin/python

import sys
import optparse
import seismometer.input
import seismometer.output
import seismometer.spool
import seismometer.messenger
import yaml
import logging
import seismometer.logging
import signal

#-----------------------------------------------------------------------------
# command line options {{{

parser = optparse.OptionParser(
    usage = "%prog [options]",
    description = "TODO"
)

parser.add_option(
    "--destination", "--dest", dest = "destination",
    action = "append", default = [],
    help = "where to send messages",
    metavar = "ADDR",
)
parser.add_option(
    "--source", "--src", dest = "source",
    action = "append", default = [],
    help = "where to read/expect messages from",
    metavar = "ADDR",
)
parser.add_option(
    "--tagfile", dest = "tag_file",
    help = "definitions used to convert Graphite-like tags to \"location\" for"
           " Seismometer Message",
    metavar = "TAGFILE",
)
parser.add_option(
    "--spool", dest = "spool_dir",
    help = "directory to spool messages in case of network problems",
    metavar = "SPOOLDIR",
)
parser.add_option(
    "--max-spool", dest = "max_spool",
    help = "how much to keep in spool before dropping the earliest messages"
           " (in bytes; allowed suffixes are 'k' and 'M')",
    metavar = "SIZE",
)
parser.add_option(
    "--logging", dest = "logging_config",
    default = None,
    help = "YAML/JSON file with logging configuration",
    metavar = "FILE",
)

# }}}
#-----------------------------------------------------------------------------

(options, args) = parser.parse_args()

if len(args) > 0:
    parser.error("too many arguments")

if len(options.source) == 0:
    options.source = ["stdin"]

if len(options.destination) == 0:
    options.destination = ["stdout"]

#-----------------------------------------------------------------------------
# configure logging {{{

if options.logging_config is not None:
    cf = open(options.logging_config)
    seismometer.logging.dictConfig(yaml.safe_load(cf))
else:
    seismometer.logging.dictConfig({
        "version": 1,
        "root": {
            "level": "WARNING",
            "handlers": ["console"],
        },
        "formatters": {
            "brief_formatter": {
                "format": "[%(name)s] %(message)s",
            },
        },
        "handlers": {
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "brief_formatter",
                "stream": "ext://sys.stderr",
            },
        },
    })

logger = logging.getLogger()

# }}}
#-----------------------------------------------------------------------------
# --source options parsing {{{

def prepare_source(source):
    if source == "stdin":
        logger.info("adding source: STDIN")
        import seismometer.input.stdin
        return seismometer.input.stdin.STDIN()

    if source.startswith("tcp:"):
        if ":" in source[4:]:
            (host, port) = source[4:].split(":")
            port = int(port)
            logger.info("adding source: TCP:*:%d", port)
        else:
            host = None
            port = int(source[4:])
            logger.info("adding source: TCP:%s:%d", host, port)
        import seismometer.input.inet
        return seismometer.input.inet.TCP(host, port)

    if source.startswith("udp:"):
        if ":" in source[4:]:
            (host, port) = source[4:].split(":")
            port = int(port)
            logger.info("adding source: UDP:*:%d", port)
        else:
            host = None
            port = int(source[4:])
            logger.info("adding source: UDP:%s:%d", host, port)
        import seismometer.input.inet
        return seismometer.input.inet.UDP(host, port)

    if source.startswith("unix:"):
        path = source[5:]
        logger.info("adding source: UNIX:%s", path)
        import seismometer.input.unix
        return seismometer.input.unix.UNIX(path)

    import json
    params = json.loads(source)
    import seismometer.input.plugin
    # TODO: log this
    # TODO: document this
    return seismometer.input.plugin.Plugin(params['class'], params)

# }}}
#-----------------------------------------------------------------------------
# --destination options parsing {{{

#-----------------------------------------------------------
# spooler creation {{{

def create_spooler():
    if options.max_spool is None:
        return None

    if options.max_spool.endswith("k") or options.max_spool.endswith("K"):
        max_spool_size = int(options.max_spool[0:-1]) * 1024
    elif options.max_spool.endswith("m") or options.max_spool.endswith("M"):
        max_spool_size = int(options.max_spool[0:-1]) * 1024 * 1024
    else:
        max_spool_size = int(options.max_spool)

    if options.spool_dir is not None:
        # TODO: implement disk spooler
        raise NotImplementedError("spooling to disk not supported yet")
    else:
        return seismometer.spool.MemorySpooler(max = max_spool_size)

# }}}
#-----------------------------------------------------------

def prepare_destination(destination):
    if destination == "stdout":
        logger.info("adding destination: STDOUT")
        import seismometer.output.stdout
        return seismometer.output.stdout.STDOUT()

    if destination.startswith("tcp:"):
        (host, port) = destination[4:].split(":")
        port = int(port)
        logger.info("adding destination: TCP:%s:%d", host, port)
        spooler = create_spooler()
        import seismometer.output.inet
        return seismometer.output.inet.TCP(host, port, spooler)

    if destination.startswith("udp:"):
        (host, port) = destination[4:].split(":")
        port = int(port)
        logger.info("adding destination: UDP:%s:%d", host, port)
        import seismometer.output.inet
        return seismometer.output.inet.UDP(host, port)

    if destination.startswith("unix:"):
        path = destination[5:]
        logger.info("adding destination: UNIX:%s", path)
        spooler = create_spooler()
        import seismometer.output.unix
        return seismometer.output.unix.UNIX(path, spooler)

    import json
    params = json.loads(destination)
    import seismometer.output.plugin
    # TODO: log this
    # TODO: document this
    return seismometer.output.plugin.Plugin(params['class'], params)

# }}}
#-----------------------------------------------------------------------------

sources      = [prepare_source(o)      for o in options.source]
destinations = [prepare_destination(o) for o in options.destination]

tag_matcher = seismometer.messenger.TagMatcher(options.tag_file)
reader = seismometer.messenger.MessengerReader(tag_matcher)
writer = seismometer.output.Writer()

for s in sources:
    reader.add(s)
for d in destinations:
    writer.add(d)

#-----------------------------------------------------------------------------

# TODO:
#   * SIGUSR1: reload logging config
#   * SIGPIPE: SIG_IGN (when can it break things and how?)

def reload_tags(sig, stack_frame):
    logger = logging.getLogger("config")
    try:
        logger.info("reloading tag matcher")
        tag_matcher.reload()
    except Exception, e:
        logger.warn("tag matcher reload problem: %s", str(e))

def quit_daemon(sig, stack_frame):
    logger.info("received signal; shutting down")
    sys.exit(0)

signal.signal(signal.SIGHUP, reload_tags)
signal.signal(signal.SIGTERM, quit_daemon)

#-----------------------------------------------------------------------------
# main loop

try:
    while True:
        message = reader.read()
        writer.write(message)
except KeyboardInterrupt:
    logger.info("received signal; shutting down")
    pass
except seismometer.input.EOF:
    # this is somewhat expected: all the input descriptors are closed (e.g.
    # only STDIN was specified)
    pass

#-----------------------------------------------------------------------------
# vim:ft=python:foldmethod=marker
